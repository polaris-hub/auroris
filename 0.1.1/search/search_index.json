{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introduction","text":"<p>Welcome to the Auroris documentation!</p>"},{"location":"api/curator.html","title":"Curator","text":""},{"location":"api/curator.html#auroris.curation.Curator","title":"auroris.curation.Curator","text":"<p>             Bases: <code>BaseModel</code></p> <p>A curator is a collection of actions that are applied to a dataset. Can be serialized.</p>"},{"location":"api/curator.html#auroris.curation.Curator.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(path: str)\n</code></pre> <p>Loads a curation workflow from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to load from</p> required"},{"location":"api/curator.html#auroris.curation.Curator.to_json","title":"to_json","text":"<pre><code>to_json(path: str)\n</code></pre> <p>Saves the curation workflow to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The destination to save to</p> required"},{"location":"api/functional.html","title":"Functional","text":""},{"location":"api/functional.html#auroris.curation.functional","title":"auroris.curation.functional","text":""},{"location":"api/functional.html#auroris.curation.functional.deduplicate","title":"deduplicate","text":"<pre><code>deduplicate(dataset: pd.DataFrame, deduplicate_on: Optional[Union[str, List[str]]] = None, y_cols: Optional[Union[str, List[str]]] = None, keep: Literal['first', 'last'] = 'first', method: Literal['mean', 'median'] = 'median') -&gt; pd.DataFrame\n</code></pre> <p>Deduplicate a dataframe.</p> <p>If <code>deduplicate_on</code> specifies a subset of all columns in the dataset and <code>y_cols</code> specifies a set of non-overlapping columns, data will be grouped by <code>deduplicate_on</code> and the <code>y_cols</code> will be aggregated to a single value per group according to <code>method</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>DataFrame</code> <p>The dataset to deduplicate.</p> required <code>deduplicate_on</code> <code>Optional[Union[str, List[str]]]</code> <p>A subset of the columns to deduplicate on (can be default).</p> <code>None</code> <code>y_cols</code> <code>Optional[Union[str, List[str]]]</code> <p>The columns to aggregate.</p> <code>None</code> <code>keep</code> <code>Literal['first', 'last']</code> <p>Whether to keep the first or last copy of the duplicates.</p> <code>'first'</code> <code>method</code> <code>Literal['mean', 'median']</code> <p>The method to aggregate the data.</p> <code>'median'</code>"},{"location":"api/functional.html#auroris.curation.functional.discretize","title":"discretize","text":"<pre><code>discretize(X: np.ndarray, thresholds: Union[np.ndarray, list], inplace: bool = False, allow_nan: bool = True, label_order: Literal['ascending', 'descending'] = 'ascending') -&gt; np.ndarray\n</code></pre> <p>Thresholding of array-like or scipy.sparse matrix into binary or multiclass labels.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <p>The data to discretize, element by element. scipy.sparse matrices should be in CSR or CSC format to avoid an un-necessary copy.</p> required <code>thresholds</code> <code>Union[ndarray, list]</code> <p>Interval boundaries that include the right bin edge.</p> required <code>inplace</code> <code>bool</code> <p>Set to True to perform inplace discretization and avoid a copy (if the input is already a numpy array or a scipy.sparse CSR / CSC matrix and if axis is 1).</p> <code>False</code> <code>allow_nan</code> <code>bool</code> <p>Set to True to allow nans in the array for discretization. Otherwise, an error will be raised instead.</p> <code>True</code> <code>label_order</code> <code>Literal['ascending', 'descending']</code> <p>The continuous values are discretized to labels 0, 1, 2, .., N with respect to given threshold bins [threshold_1, threshold_2,.., threshould_n]. When set to 'ascending', the class label is in ascending order with the threshold bins that <code>0</code> represents negative class or lower class, while 1, 2, 3 are for higher classes. When set to 'descending' the class label is in ascending order with the threshold bins. Sometimes the positive labels are on the left side of provided threshold. E.g. For binarization with threshold [0.5],  the positive label is defined by<code>X &lt; 0.5</code>. In this case, <code>label_order</code> should be <code>descending</code>.</p> <code>'ascending'</code> <p>Returns:</p> Name Type Description <code>X_tr</code> <code>ndarray</code> <p>The transformed data.</p>"},{"location":"api/functional.html#auroris.curation.functional.detect_outliers","title":"detect_outliers","text":"<pre><code>detect_outliers(X: np.ndarray, method: OutlierDetectionMethod = 'zscore', **kwargs: Any)\n</code></pre> <p>Functional interface for detecting outliers</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>The observations that we want to classify as inliers or outliers.</p> required <code>method</code> <code>OutlierDetectionMethod</code> <p>The method to use for outlier detection.</p> <code>'zscore'</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments for the outlier detection method.</p> <code>{}</code>"},{"location":"api/types.html","title":"Types","text":""},{"location":"api/types.html#auroris.types","title":"auroris.types","text":""},{"location":"api/visualization.html","title":"Visualization","text":""},{"location":"api/visualization.html#auroris.visualization","title":"auroris.visualization","text":""},{"location":"api/visualization.html#auroris.visualization.visualize_chemspace","title":"visualize_chemspace","text":"<pre><code>visualize_chemspace(X: Union[List[np.ndarray], np.ndarray], y: Optional[Union[List[np.ndarray], np.ndarray]] = None, labels: Optional[List[str]] = None, n_cols: int = 3, fig_base_size: float = 8, w_h_ratio: float = 0.5, dpi: int = 150, seaborn_theme: Optional[str] = 'whitegrid', **umap_kwargs: Any)\n</code></pre> <p>Plot the chemical space. Also, color based on the target values.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>Union[List[ndarray], ndarray]</code> <p>A list of arrays with the features.</p> required <code>y</code> <code>Optional[Union[List[ndarray], ndarray]]</code> <p>A list of arrays with the target values.</p> <code>None</code> <code>labels</code> <code>Optional[List[str]]</code> <p>Optional list of labels for each set of features.</p> <code>None</code> <code>n_cols</code> <code>int</code> <p>Number of columns in the subplots.</p> <code>3</code> <code>fig_base_size</code> <code>float</code> <p>Base size of the plots.</p> <code>8</code> <code>w_h_ratio</code> <code>float</code> <p>Width/height ratio.</p> <code>0.5</code> <code>dpi</code> <code>int</code> <p>DPI value of the figure.</p> <code>150</code> <code>seaborn_theme</code> <code>Optional[str]</code> <p>Seaborn theme.</p> <code>'whitegrid'</code> <code>**umap_kwargs</code> <code>Any</code> <p>Keyword arguments for the UMAP algorithm.</p> <code>{}</code>"},{"location":"api/visualization.html#auroris.visualization.visualize_continuous_distribution","title":"visualize_continuous_distribution","text":"<pre><code>visualize_continuous_distribution(data: np.ndarray, log_scale: bool = False, bins: Optional[Sequence[float]] = None)\n</code></pre> <p>KDE plot the distribution of the column in <code>data</code> with colored sections under the KDE curve.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>A 1D numpy array with the values to plot the distribution for.</p> required <code>log_scale</code> <code>bool</code> <p>Whether to plot the x-axis in log scale.</p> <code>False</code> <code>bins</code> <code>Optional[Sequence[float]]</code> <p>The bin boundaries to color the area under the KDE curve.</p> <code>None</code>"},{"location":"api/visualization.html#auroris.visualization.visualize_distribution_with_outliers","title":"visualize_distribution_with_outliers","text":"<pre><code>visualize_distribution_with_outliers(values: np.ndarray, is_outlier: Optional[List[bool]] = None)\n</code></pre> <p>Visualize the distribution of the data and highlight the potential outliers.</p>"},{"location":"api/actions/deduplication.html","title":"Deduplication","text":""},{"location":"api/actions/deduplication.html#auroris.curation.actions.Deduplication","title":"auroris.curation.actions.Deduplication","text":"<p>             Bases: <code>BaseAction</code></p> <p>Automatic detection of outliers.</p>"},{"location":"api/actions/discretization.html","title":"Discretization","text":""},{"location":"api/actions/discretization.html#auroris.curation.actions.Discretization","title":"auroris.curation.actions.Discretization","text":"<p>             Bases: <code>BaseAction</code></p>"},{"location":"api/actions/mol.html","title":"Molecule Curation","text":""},{"location":"api/actions/mol.html#auroris.curation.actions.MoleculeCuration","title":"auroris.curation.actions.MoleculeCuration","text":"<p>             Bases: <code>BaseAction</code></p> <p>Attributes:</p> Name Type Description <code>input_column</code> <code>str</code> <p>The name of the column that has the molecules (either <code>dm.Mol</code> objects or SMILES).</p> <code>remove_salt_solvent</code> <code>bool</code> <p>When set to 'True', all disconnected salts and solvents will be removed from molecule. In most of the cases, it is recommended to remove the salts/solvents.</p> <code>remove_stereo</code> <code>bool</code> <p>Whether remove stereochemistry information from molecule. If it's known that the stereochemistry do not contribute to the bioactivity of interest, the stereochemistry information can be removed.</p>"},{"location":"api/actions/outlier_detection.html","title":"Outlier Detection","text":""},{"location":"api/actions/outlier_detection.html#auroris.curation.actions.OutlierDetection","title":"auroris.curation.actions.OutlierDetection","text":"<p>             Bases: <code>BaseAction</code></p> <p>Automatic detection of outliers.</p>"},{"location":"api/actions/stereo_ac.html","title":"Stereoisomer AC","text":""},{"location":"api/actions/stereo_ac.html#auroris.curation.actions.StereoIsomerACDetection","title":"auroris.curation.actions.StereoIsomerACDetection","text":"<p>             Bases: <code>BaseAction</code></p> <p>Automatic detection of outliers.</p>"},{"location":"tutorials/getting_started.html","title":"Getting Started","text":"<p>In short</p> <p>This tutorial gives an overview of the basic concepts in the `auroris` library.</p> <p>On the nuances of curation</p> <p>How to best curate a dataset is highly situation-dependent. The `auroris` library includes some useful tools, but blindly applying them won't necessarily lead to good datasets. To learn more, visit the Polaris Hub for extensive resources and documentation on dataset curation and more.</p> <p>Data curation is concerned with analyzing and processing an existing dataset to maximize its quality. Within drug discovery, this can imply many things, such as filtering out outliers or flagging activity-cliffs. High-quality, well-curated datasets are the foundation upon which we can build realistic, impactful benchmarks for drug discovery. This notebook demonstrates how to curate your dataset with the Polaris data curation API for small molecules.</p> In\u00a0[3]: Copied! <pre>import datamol as dm\n</pre> import datamol as dm In\u00a0[4]: Copied! <pre># Load your data set\n# See more details of the dataset at https://docs.datamol.io/stable/api/datamol.data.html\ndataset = dm.data.solubility()\ndataset.head(5)\n</pre> # Load your data set # See more details of the dataset at https://docs.datamol.io/stable/api/datamol.data.html dataset = dm.data.solubility() dataset.head(5) Out[4]: mol ID NAME SOL SOL_classification smiles split 0 &lt;rdkit.Chem.rdchem.Mol object at 0x1570f9d90&gt; 1 n-pentane -3.18 (A) low CCCCC train 1 &lt;rdkit.Chem.rdchem.Mol object at 0x1570f9ee0&gt; 2 cyclopentane -2.64 (B) medium C1CCCC1 train 2 &lt;rdkit.Chem.rdchem.Mol object at 0x1570f9f50&gt; 3 n-hexane -3.84 (A) low CCCCCC train 3 &lt;rdkit.Chem.rdchem.Mol object at 0x1570f9fc0&gt; 4 2-methylpentane -3.74 (A) low CCCC(C)C train 4 &lt;rdkit.Chem.rdchem.Mol object at 0x1570fa030&gt; 6 2,2-dimethylbutane -3.55 (A) low CCC(C)(C)C train In\u00a0[5]: Copied! <pre>from auroris.curation import Curator\nfrom auroris.curation.actions import MoleculeCuration, OutlierDetection, Discretization\n\n# Define the curation workflow\ncurator = Curator(\n    steps=[\n        MoleculeCuration(input_column=\"smiles\"),\n        OutlierDetection(method=\"zscore\", columns=[\"SOL\"]),\n        Discretization(input_column=\"SOL\", thresholds=[-3]),\n    ],\n    parallelized_kwargs = { \"n_jobs\": -1 }\n)\n\n# Run the curation\ndataset, report = curator(dataset)\n</pre> from auroris.curation import Curator from auroris.curation.actions import MoleculeCuration, OutlierDetection, Discretization  # Define the curation workflow curator = Curator(     steps=[         MoleculeCuration(input_column=\"smiles\"),         OutlierDetection(method=\"zscore\", columns=[\"SOL\"]),         Discretization(input_column=\"SOL\", thresholds=[-3]),     ],     parallelized_kwargs = { \"n_jobs\": -1 } )  # Run the curation dataset, report = curator(dataset) <p>The report can be exported (\"broadcaster\") to a variety of different formats. Let's simply log it to the CLI for now.</p> In\u00a0[6]: Copied! <pre>from auroris.report.broadcaster import LoggerBroadcaster\n\nbroadcaster = LoggerBroadcaster(report)\nbroadcaster.broadcast()\n</pre> from auroris.report.broadcaster import LoggerBroadcaster  broadcaster = LoggerBroadcaster(report) broadcaster.broadcast() <pre>===== Curation Report =====\nTime: 2024-05-02 13:20:55\nVersion: dev\n===== MoleculeCuration =====\n[LOG]: Couldn't preprocess 18 / 1282 molecules.\n[LOG]: New column added: MOL_smiles\n[LOG]: New column added: MOL_molhash_id\n[LOG]: New column added: MOL_molhash_id_no_stereo\n[LOG]: New column added: MOL_num_stereoisomers\n[LOG]: New column added: MOL_num_undefined_stereoisomers\n[LOG]: New column added: MOL_num_defined_stereo_center\n[LOG]: New column added: MOL_num_undefined_stereo_center\n[LOG]: New column added: MOL_num_stereo_center\n[LOG]: New column added: MOL_undefined_E_D\n[LOG]: New column added: MOL_undefined_E/Z\n[IMG]: Dimensions 1200 x 600\n[IMG]: Dimensions None x None\n===== OutlierDetection =====\n[LOG]: New column added: OUTLIER_SOL\n[IMG]: Dimensions 2400 x 600\n===== Discretization =====\n[LOG]: New column added: CLS_SOL\n</pre> <p>We can see that there is also images in the report! More advanced broadcasters will display these, such as the <code>HTMLBroadcaster</code>.</p> In\u00a0[\u00a0]: Copied! <pre>from auroris.report.broadcaster import HTMLBroadcaster\n\nbroadcaster = HTMLBroadcaster(report, \"/path/to/broadcaster\")\nbroadcaster.broadcast()\n</pre> from auroris.report.broadcaster import HTMLBroadcaster  broadcaster = HTMLBroadcaster(report, \"/path/to/broadcaster\") broadcaster.broadcast() <p>Let's also look at a single row of the new curated dataset!</p> In\u00a0[8]: Copied! <pre>dataset.iloc[0]\n</pre> dataset.iloc[0] Out[8]: <pre>mol                                &lt;rdkit.Chem.rdchem.Mol object at 0x1570f9d90&gt;\nID                                                                             1\nNAME                                                                   n-pentane\nSOL                                                                        -3.18\nSOL_classification                                                       (A) low\nsmiles                                                                     CCCCC\nsplit                                                                      train\nMOL_smiles                                                                 CCCCC\nMOL_molhash_id                          3cb2e0cf1b50d8f954891abc5dcce90d543cd3d7\nMOL_molhash_id_no_stereo                36551d628217a351e720cdbe676fca3067730a91\nMOL_num_stereoisomers                                                        1.0\nMOL_num_undefined_stereoisomers                                              1.0\nMOL_num_defined_stereo_center                                                0.0\nMOL_num_undefined_stereo_center                                              0.0\nMOL_num_stereo_center                                                        0.0\nMOL_undefined_E_D                                                          False\nMOL_undefined_E/Z                                                              0\nOUTLIER_SOL                                                                  0.0\nCLS_SOL                                                                      0.0\nName: 0, dtype: object</pre> In\u00a0[9]: Copied! <pre>from auroris.curation.functional import detect_outliers\nfrom auroris.visualization import visualize_distribution_with_outliers\n\ny = dataset[\"SOL\"].values\nis_outlier = detect_outliers(y)\nvisualize_distribution_with_outliers(y, is_outlier);\n</pre> from auroris.curation.functional import detect_outliers from auroris.visualization import visualize_distribution_with_outliers  y = dataset[\"SOL\"].values is_outlier = detect_outliers(y) visualize_distribution_with_outliers(y, is_outlier); <p>The End.</p>"},{"location":"tutorials/getting_started.html#curating-a-toy-dataset","title":"Curating a toy dataset\u00b6","text":"<p>Let's learn about the basic concepts of the <code>auroris</code> library by curating a toy dataset. For the sake of simplicity, we will use the solubility dataset from Datamol. It is worth noting that this dataset is only meant to be used as a toy dataset for pedagogic and testing purposes. It is not a dataset for benchmarking, analysis or model training. Curation can only take us so far. For impactful benchmarks, we rely on high-quality data sources to begin with.</p>"},{"location":"tutorials/getting_started.html#using-the-curator-api","title":"Using the <code>Curator</code> API\u00b6","text":"<p>The recommended way to specify curation workflows is through the <code>Curator</code> API:</p> <ul> <li>A <code>Curator</code> object defines a number of curation steps.</li> <li>Each step should inherit from <code>auroris.curation.actions.BaseAction</code>.</li> <li>The <code>Curator</code> object is serializable. You can thus easily save and load it from JSON, which makes it easy to reproduce a curation workflow.</li> <li>Finally, the <code>Curator</code> produces a <code>CurationReport</code> which summarizes the changes made to a dataset.</li> </ul> <p>Let's define a simple workflow with three steps:</p> <ol> <li>Curate the chemical structures</li> <li>Detect outliers</li> <li>Bin the regression column</li> </ol>"},{"location":"tutorials/getting_started.html#using-the-functional-api","title":"Using the functional API\u00b6","text":"<p><code>auroris</code> provides a functional API to easily and quickly run some curation steps. Let's look at an oulier detection example.</p>"}]}