{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introduction","text":"<p>Welcome to the Auroris - Simplifying Drug Discovery Data Curation</p>"},{"location":"index.html#what-is-auroris","title":"What is Auroris?","text":"<p>Auroris is a Python library designed to assist researchers and scientists in managing, cleaning, and preparing data relevant to drug discovery. Auroris will implement a range of techniques to handle, transform, filter, analyze, or visualize the diverse data types commonly encountered in drug discovery. </p> <p>Currently, Auroris supports curation for small molecules, with plans to extend to other modalities in drug discovery. The curation module for small molecules includes:</p> <ul> <li> <p>\ud83d\uddc4\ufe0f Molecule Standardization: Ensures that each molecule is represented in a uniform and unambiguous form.</p> </li> <li> <p>\ud83c\udff7\ufe0f Detection of Duplicate Molecules with Contradictory Labels: Identifies and resolves inconsistencies in activity data for each molecule.</p> </li> <li> <p>\u26f0\ufe0f Detection of Activity Cliffs Between Stereoisomers: Identifies significant differences in activity between stereoisomers.</p> </li> <li> <p>\ud83d\udd0dOutlier Detection and Visualization: Detects and visualizes outliers in molecular activity data.</p> </li> <li> <p>\ud83d\udcfd\ufe0f Visualization of Molecular Distribution in Chemical Space: Provides graphical representations of molecular distributions.</p> </li> </ul> <p>Reproducibility and transparency are core to the mission of Polaris. That\u2019s why with Auroris, you can also automatically generate detailed reports summarizing the changes that happened to a dataset during curation. Through an intuitive API, you can easily define complex curation workflows. Once defined, that workflow is serializable and thus reproducible so you can transparently share how you curated the dataset.</p>"},{"location":"index.html#where-to-next","title":"Where to next?","text":"<p>  Quickstart</p> <p>Dive deeper into the Auroris code and learn how to curate data for your ML-powered drug discovery program. </p> <p> Let's get started</p> <p>  API Reference</p> <p>Explore the technical documentation here to delve into the inner workings of the code. Gain insights into the intricate details of how different methods and classes function.</p> <p> Let's get started</p> <p>  Community</p> <p>We're excited to have you join us in revolutionizing drug discovery data curation! Explore Auroris and the broader Polaris ecosystem it is part of, provide feedback, share your use cases, and collaborate with us to enhance and expand the capabilities of Auroris for the benefit of the drug discovery community.</p> <p> Let's get started</p>"},{"location":"api/actions.html","title":"Actions","text":""},{"location":"api/actions.html#auroris.curation.actions.BaseAction","title":"auroris.curation.actions.BaseAction","text":"<p>               Bases: <code>BaseModel</code>, <code>ABC</code></p> <p>An action in the curation process.</p> The importance of reproducibility <p>One of the main goals in designing <code>auroris</code> is to make it easy to reproduce the curation process. Reproducibility is key to scientific research. This is why a BaseAction needs to be serializable and uniquely identified by a <code>name</code>.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name that uniquely identifies the action. This is used to serialize and deserialize the action.</p> <code>prefix</code> <code>str</code> <p>This prefix is used when an action adds columns to a dataset. If not set, it defaults to the name in uppercase.</p>"},{"location":"api/actions.html#auroris.curation.actions.StereoIsomerACDetection","title":"StereoIsomerACDetection","text":"<p>               Bases: <code>BaseAction</code></p> <p>Automatic detection of activity shift between stereoisomers.</p> <p>See <code>auroris.curation.functional.detect_streoisomer_activity_cliff</code> for the docs of the <code>stereoisomer_id_col</code>, <code>y_cols</code> and <code>threshold</code> attributes</p> <p>Attributes:</p> Name Type Description <code>mol_col</code> <code>Optional[str]</code> <p>Column with the SMILES or RDKit Molecule objects. If specified, will be used to render an image for the activity cliffs.</p>"},{"location":"api/actions.html#auroris.curation.actions.Deduplication","title":"Deduplication","text":"<p>               Bases: <code>BaseAction</code></p> <p>Automatic detection of outliers.</p> <p>See <code>auroris.curation.functional.deduplicate</code> for the docs of the <code>deduplicate_on</code>, <code>y_cols</code>, <code>keep</code> and <code>method</code> attributes</p>"},{"location":"api/actions.html#auroris.curation.actions.Discretization","title":"Discretization","text":"<p>               Bases: <code>BaseAction</code></p> <p>Thresholding bioactivity columns to binary or multiclass labels.</p> <p>See <code>auroris.curation.functional.discretize</code> for the docs of the <code>thresholds</code>, <code>inplace</code>, <code>allow_nan</code> and <code>label_order</code> attributes</p> <p>Attributes:</p> Name Type Description <code>input_column</code> <code>str</code> <p>The column to discretize.</p> <code>log_scale</code> <code>bool</code> <p>Whether a visual depiction of the discretization should be on a log scale.</p>"},{"location":"api/actions.html#auroris.curation.actions.ContinuousDistributionVisualization","title":"ContinuousDistributionVisualization","text":"<p>               Bases: <code>BaseAction</code></p> <p>Visualize one or more continuous distribution(s).</p> <p>See <code>auroris.visualization.visualize_continuous_distribution</code> for the docs of the <code>log_scale</code> and <code>bins</code> attributes</p> <p>Attributes:</p> Name Type Description <code>y_cols</code> <code>List[str]</code> <p>The columns whose distributions should be visualized.</p>"},{"location":"api/actions.html#auroris.curation.actions.MoleculeCuration","title":"MoleculeCuration","text":"<p>               Bases: <code>BaseAction</code></p> <p>Automated molecule curation and chemistry space distribution.</p> <p>See <code>auroris.curation.functional.curate_molecules</code> for the docs of the <code>remove_stereo</code>, <code>fix_mol</code>, <code>count_stereoisomers</code>, and <code>count_stereocenters</code> attributes</p> <p>Attributes:</p> Name Type Description <code>input_column</code> <code>str</code> <p>The name of the column that has the molecules (either <code>dm.Mol</code> objects or SMILES).</p> <code>X_col</code> <code>Optional[str]</code> <p>Column with custom features for each of the molecules. If None, will use ECFP.</p> <code>y_cols</code> <code>Optional[Union[str, List[str]]]</code> <p>Column names for bioactivities, which will be used to colorcode the chemical space visualization.</p>"},{"location":"api/actions.html#auroris.curation.actions.OutlierDetection","title":"OutlierDetection","text":"<p>               Bases: <code>BaseAction</code></p> <p>Automatic detection of outliers.</p> <p>See <code>auroris.curation.functional.detect_outliers</code> for the docs of the <code>method</code> and <code>kwargs</code> attributes</p> <p>Attributes:</p> Name Type Description <code>columns</code> <code>List[str]</code> <p>The columns for which to detect outliers.</p>"},{"location":"api/curator.html","title":"Curator","text":""},{"location":"api/curator.html#auroris.curation.Curator","title":"auroris.curation.Curator","text":"<p>               Bases: <code>BaseModel</code></p> <p>A curator is a serializable collection of actions that are applied to a dataset.</p> <p>Attributes:</p> Name Type Description <code>steps</code> <code>List[BaseAction]</code> <p>Ordered list of curation actions to apply to the dataset.</p> <code>src_dataset_path</code> <code>Optional[str]</code> <p>An optional path to load the source dataset from. Can be used to specify a reproducible workflow.</p> <code>verbosity</code> <code>VerbosityLevel</code> <p>Verbosity level for logging.</p> <code>parallelized_kwargs</code> <code>dict</code> <p>Keyword arguments to affect parallelization in the steps.</p>"},{"location":"api/curator.html#auroris.curation.Curator.transform","title":"transform","text":"<pre><code>transform(dataset: Optional[pd.DataFrame] = None) -&gt; Tuple[pd.DataFrame, CurationReport]\n</code></pre> <p>Runs the curation process.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>Optional[DataFrame]</code> <p>The dataset to be curated. If <code>src_dataset_path</code> is set, this parameter is ignored.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[DataFrame, CurationReport]</code> <p>A tuple of the curated dataset and a report summarizing the changes made.</p>"},{"location":"api/curator.html#auroris.curation.Curator.load_dataset","title":"load_dataset  <code>staticmethod</code>","text":"<pre><code>load_dataset(path: str)\n</code></pre> <p>Loads a dataset, to be curated, from a path.</p> File-format support <p>This currently only supports CSV and Parquet files and uses the default parameters for <code>pd.read_csv</code> and <code>pd.read_parquet</code>. If you need more flexibility, consider loading the data yourself and passing it directly to <code>Curator.transform(dataset=...)</code>.</p>"},{"location":"api/curator.html#auroris.curation.Curator.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(path: str)\n</code></pre> <p>Loads a curation workflow from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to load from</p> required"},{"location":"api/curator.html#auroris.curation.Curator.to_json","title":"to_json","text":"<pre><code>to_json(path: str)\n</code></pre> <p>Saves the curation workflow to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The destination to save to.</p> required"},{"location":"api/functional.html","title":"Curation","text":""},{"location":"api/functional.html#auroris.curation.functional.detect_streoisomer_activity_cliff","title":"detect_streoisomer_activity_cliff","text":"<pre><code>detect_streoisomer_activity_cliff(dataset: pd.DataFrame, stereoisomer_id_col: str, y_cols: List[str], threshold: float = 2.0, prefix: str = 'AC_') -&gt; pd.DataFrame\n</code></pre> <p>Detect activity cliff among stereoisomers based on classification label or pre-defined threshold for continuous values.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>DataFrame</code> <p>Dataframe</p> required <code>stereoisomer_id_col</code> <code>str</code> <p>Column which identifies the stereoisomers</p> required <code>y_cols</code> <code>List[str]</code> <p>List of columns for bioactivities</p> required <code>threshold</code> <code>float</code> <p>Threshold to identify the activity cliff. Currently, the difference of zscores between isomers are used for identification.</p> <code>2.0</code> <code>prefix</code> <code>str</code> <p>Prefix for the adding columns</p> <code>'AC_'</code>"},{"location":"api/functional.html#auroris.curation.functional.deduplicate","title":"deduplicate","text":"<pre><code>deduplicate(dataset: pd.DataFrame, deduplicate_on: Optional[Union[str, List[str]]] = None, y_cols: Optional[Union[str, List[str]]] = None, keep: Literal['first', 'last'] = 'first', method: Literal['mean', 'median'] = 'median') -&gt; pd.DataFrame\n</code></pre> <p>Deduplicate a dataframe.</p> <p>If <code>deduplicate_on</code> specifies a subset of all columns in the dataset and <code>y_cols</code> specifies a set of non-overlapping columns, data will be grouped by <code>deduplicate_on</code> and the <code>y_cols</code> will be aggregated to a single value per group according to <code>method</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>DataFrame</code> <p>The dataset to deduplicate.</p> required <code>deduplicate_on</code> <code>Optional[Union[str, List[str]]]</code> <p>A subset of the columns to deduplicate on (can be default).</p> <code>None</code> <code>y_cols</code> <code>Optional[Union[str, List[str]]]</code> <p>The columns to aggregate.</p> <code>None</code> <code>keep</code> <code>Literal['first', 'last']</code> <p>Whether to keep the first or last copy of the duplicates.</p> <code>'first'</code> <code>method</code> <code>Literal['mean', 'median']</code> <p>The method to aggregate the data.</p> <code>'median'</code>"},{"location":"api/functional.html#auroris.curation.functional.discretize","title":"discretize","text":"<pre><code>discretize(X: np.ndarray, thresholds: Union[np.ndarray, list], inplace: bool = False, allow_nan: bool = True, label_order: Literal['ascending', 'descending'] = 'ascending') -&gt; np.ndarray\n</code></pre> <p>Thresholding of array-like or scipy.sparse matrix into binary or multiclass labels.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <p>The data to discretize, element by element. scipy.sparse matrices should be in CSR or CSC format to avoid an un-necessary copy.</p> required <code>thresholds</code> <code>Union[ndarray, list]</code> <p>Interval boundaries that include the right bin edge.</p> required <code>inplace</code> <code>bool</code> <p>Set to True to perform inplace discretization and avoid a copy (if the input is already a numpy array or a scipy.sparse CSR / CSC matrix and if axis is 1).</p> <code>False</code> <code>allow_nan</code> <code>bool</code> <p>Set to True to allow nans in the array for discretization. Otherwise, an error will be raised instead.</p> <code>True</code> <code>label_order</code> <code>Literal['ascending', 'descending']</code> <p>The continuous values are discretized to labels 0, 1, 2, .., N with respect to given threshold bins [threshold_1, threshold_2,.., threshould_n]. When set to 'ascending', the class label is in ascending order with the threshold bins that <code>0</code> represents negative class or lower class, while 1, 2, 3 are for higher classes. When set to 'descending' the class label is in ascending order with the threshold bins. Sometimes the positive labels are on the left side of provided threshold. E.g. For binarization with threshold [0.5],  the positive label is defined by<code>X &lt; 0.5</code>. In this case, <code>label_order</code> should be <code>descending</code>.</p> <code>'ascending'</code> <p>Returns:</p> Name Type Description <code>X_tr</code> <code>ndarray</code> <p>The transformed data.</p>"},{"location":"api/functional.html#auroris.curation.functional.curate_molecules","title":"curate_molecules","text":"<pre><code>curate_molecules(mols: List[Union[str, dm.Mol]], progress: bool = True, remove_stereo: bool = False, fix_mol: bool = True, count_stereoisomers: bool = True, count_stereocenters: bool = True, **parallelized_kwargs) -&gt; Tuple\n</code></pre> <p>Curate a list of molecules.</p> <p>Parameters:</p> Name Type Description Default <code>mols</code> <code>List[Union[str, Mol]]</code> <p>List of molecules.</p> required <code>progress</code> <code>bool</code> <p>Whether show curation progress.</p> <code>True</code> <code>fix_mol</code> <code>bool</code> <p>Whether fix the error in molecule.</p> <code>True</code> <code>remove_stereo</code> <code>bool</code> <p>Whether remove stereo chemistry information from molecule.</p> <code>False</code> <code>count_stereoisomers</code> <code>bool</code> <p>Whether count the number of stereoisomers of molecule.</p> <code>True</code> <code>count_stereocenters</code> <code>bool</code> <p>Whether count the number of stereocenters of molecule.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>mol_dict</code> <code>Tuple</code> <p>Dictionary of molecule and additional metadata</p> <code>num_invalid</code> <code>Tuple</code> <p>Number of inv\u00df\u00dfalid molecules</p>"},{"location":"api/functional.html#auroris.curation.functional.detect_outliers","title":"detect_outliers","text":"<pre><code>detect_outliers(X: np.ndarray, method: OutlierDetectionMethod = 'zscore', **kwargs: Any)\n</code></pre> <p>Functional interface for detecting outliers</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>The observations that we want to classify as inliers or outliers.</p> required <code>method</code> <code>OutlierDetectionMethod</code> <p>The method to use for outlier detection.</p> <code>'zscore'</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments for the outlier detection method.</p> <code>{}</code>"},{"location":"api/types.html","title":"Types","text":""},{"location":"api/types.html#auroris.types","title":"auroris.types","text":""},{"location":"api/types.html#auroris.types.VerbosityLevel","title":"VerbosityLevel","text":"<p>               Bases: <code>IntEnum</code></p> <p>The different verbosity levels</p>"},{"location":"api/utils.html","title":"Utils","text":""},{"location":"api/utils.html#auroris.utils.is_regression","title":"is_regression","text":"<pre><code>is_regression(values: np.ndarray) -&gt; bool\n</code></pre> <p>Whether the input values are for regreesion</p>"},{"location":"api/utils.html#auroris.utils.fig2img","title":"fig2img","text":"<pre><code>fig2img(fig: Figure) -&gt; ImageType\n</code></pre> <p>Convert a Matplotlib figure to a PIL Image</p>"},{"location":"api/utils.html#auroris.utils.img2bytes","title":"img2bytes","text":"<pre><code>img2bytes(image: ImageType)\n</code></pre> <p>Convert png image to bytes</p>"},{"location":"api/utils.html#auroris.utils.bytes2img","title":"bytes2img","text":"<pre><code>bytes2img(image_bytes: ByteString)\n</code></pre> <p>Convert bytes to PIL image</p>"},{"location":"api/utils.html#auroris.utils.save_image","title":"save_image","text":"<pre><code>save_image(image: ImageType, path: str)\n</code></pre> <p>Save an image to a fsspec-compatible path</p>"},{"location":"api/utils.html#auroris.utils.is_parquet_file","title":"is_parquet_file","text":"<pre><code>is_parquet_file(path)\n</code></pre> <p>Verify parquet file without actually loading it.</p>"},{"location":"api/visualization.html","title":"Visualization","text":""},{"location":"api/visualization.html#auroris.visualization.visualize_chemspace","title":"visualize_chemspace","text":"<pre><code>visualize_chemspace(X: np.ndarray, y: Optional[Union[List[np.ndarray], np.ndarray]] = None, labels: Optional[List[str]] = None, n_cols: int = 2, fig_base_size: float = 8, w_h_ratio: float = 0.5, dpi: int = 150, seaborn_theme: Optional[str] = 'whitegrid', plot_kwargs: dict = None, umap_kwargs: dict = None)\n</code></pre> <p>Plot the coverage in chemical space. Also, color based on the target values.</p> <p>Parameters:</p> Name Type Description Default <code>X</code> <code>ndarray</code> <p>Array the molecular features.</p> required <code>y</code> <code>Optional[Union[List[ndarray], ndarray]]</code> <p>A list of arrays with the target values.</p> <code>None</code> <code>labels</code> <code>Optional[List[str]]</code> <p>Optional list of labels for each set of features.</p> <code>None</code> <code>n_cols</code> <code>int</code> <p>Number of columns in the subplots.</p> <code>2</code> <code>fig_base_size</code> <code>float</code> <p>Base size of the plots.</p> <code>8</code> <code>w_h_ratio</code> <code>float</code> <p>Width/height ratio.</p> <code>0.5</code> <code>dpi</code> <code>int</code> <p>DPI value of the figure.</p> <code>150</code> <code>seaborn_theme</code> <code>Optional[str]</code> <p>Seaborn theme.</p> <code>'whitegrid'</code> <code>plot_kwargs</code> <code>dict</code> <p>seaborn plot arguments.</p> <code>None</code> <code>umap_kwargs</code> <code>dict</code> <p>Keyword arguments for the UMAP algorithm.</p> <code>None</code>"},{"location":"api/visualization.html#auroris.visualization.visualize_continuous_distribution","title":"visualize_continuous_distribution","text":"<pre><code>visualize_continuous_distribution(data: np.ndarray, log_scale: bool = False, bins: Optional[Sequence[float]] = None)\n</code></pre> <p>KDE plot the distribution of the column in <code>data</code> with colored sections under the KDE curve.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ndarray</code> <p>A 1D numpy array with the values to plot the distribution for.</p> required <code>log_scale</code> <code>bool</code> <p>Whether to plot the x-axis in log scale.</p> <code>False</code> <code>bins</code> <code>Optional[Sequence[float]]</code> <p>The bin boundaries to color the area under the KDE curve.</p> <code>None</code>"},{"location":"api/visualization.html#auroris.visualization.visualize_distribution_with_outliers","title":"visualize_distribution_with_outliers","text":"<pre><code>visualize_distribution_with_outliers(values: np.ndarray, is_outlier: Optional[List[bool]] = None, title: str = 'Probability Plot')\n</code></pre> <p>Visualize the distribution of the data and highlight the potential outliers.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>ndarray</code> <p>Values for visulization.</p> required <code>is_outlier</code> <code>Optional[List[bool]]</code> <p>List of outlier flag.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title of plot</p> <code>'Probability Plot'</code>"},{"location":"tutorials/getting_started.html","title":"Getting Started","text":"<p>In short</p> <p>This tutorial gives an overview of the basic concepts in the `auroris` library.</p> <p>On the nuances of curation</p> <p>How to best curate a dataset is highly situation-dependent. The `auroris` library includes some useful tools, but blindly applying them won't necessarily lead to good datasets. To learn more, visit the Polaris Hub for extensive resources and documentation on dataset curation and more.</p> <p>Data curation is concerned with analyzing and processing an existing dataset to maximize its quality. Within drug discovery, this can imply many things, such as filtering out outliers or flagging activity-cliffs. High-quality, well-curated datasets are the foundation upon which we can build realistic, impactful benchmarks for drug discovery. This notebook demonstrates how to curate your dataset with the Polaris data curation API for small molecules.</p> In\u00a0[3]: Copied! <pre>import datamol as dm\n</pre> import datamol as dm In\u00a0[4]: Copied! <pre># Load your data set\n# See more details of the dataset at https://docs.datamol.io/stable/api/datamol.data.html\ndata = dm.data.solubility()\ndata.head(5)\n</pre> # Load your data set # See more details of the dataset at https://docs.datamol.io/stable/api/datamol.data.html data = dm.data.solubility() data.head(5) Out[4]: mol ID NAME SOL SOL_classification smiles split 0 &lt;rdkit.Chem.rdchem.Mol object at 0x173b7c2e0&gt; 1 n-pentane -3.18 (A) low CCCCC train 1 &lt;rdkit.Chem.rdchem.Mol object at 0x173b7c430&gt; 2 cyclopentane -2.64 (B) medium C1CCCC1 train 2 &lt;rdkit.Chem.rdchem.Mol object at 0x173b7c4a0&gt; 3 n-hexane -3.84 (A) low CCCCCC train 3 &lt;rdkit.Chem.rdchem.Mol object at 0x173b7c510&gt; 4 2-methylpentane -3.74 (A) low CCCC(C)C train 4 &lt;rdkit.Chem.rdchem.Mol object at 0x173b7c580&gt; 6 2,2-dimethylbutane -3.55 (A) low CCC(C)(C)C train In\u00a0[5]: Copied! <pre>from auroris.curation import Curator\nfrom auroris.curation.actions import MoleculeCuration, OutlierDetection, Discretization\n\n# Define the curation workflow\ncurator = Curator(\n    steps=[\n        MoleculeCuration(input_column=\"smiles\"),\n        OutlierDetection(method=\"zscore\", columns=[\"SOL\"]),\n        Discretization(input_column=\"SOL\", thresholds=[-3]),\n    ],\n    parallelized_kwargs={\"n_jobs\": -1},\n)\n\n# Run the curation\ndataset, report = curator(data)\n</pre> from auroris.curation import Curator from auroris.curation.actions import MoleculeCuration, OutlierDetection, Discretization  # Define the curation workflow curator = Curator(     steps=[         MoleculeCuration(input_column=\"smiles\"),         OutlierDetection(method=\"zscore\", columns=[\"SOL\"]),         Discretization(input_column=\"SOL\", thresholds=[-3]),     ],     parallelized_kwargs={\"n_jobs\": -1}, )  # Run the curation dataset, report = curator(data) <pre>2024-08-02 12:26:54.316 | INFO     | auroris.curation._curator:transform:106 - Performing step: mol_curation\n2024-08-02 12:27:12.343 | INFO     | auroris.curation._curator:transform:106 - Performing step: outlier_detection\n2024-08-02 12:27:12.400 | INFO     | auroris.curation._curator:transform:106 - Performing step: discretize\n</pre> <p>The report can be exported (\"broadcaster\") to a variety of different formats. Let's simply log it to the CLI for now.</p> In\u00a0[6]: Copied! <pre>from auroris.report.broadcaster import LoggerBroadcaster\n\nbroadcaster = LoggerBroadcaster(report)\nbroadcaster.broadcast()\n</pre> from auroris.report.broadcaster import LoggerBroadcaster  broadcaster = LoggerBroadcaster(report) broadcaster.broadcast() <pre>===== Curation Report =====\nTime: 2024-08-02 12:26:54\nVersion: 0.1.4.dev0+g7127343.d20240707\n===== mol_curation =====\n[LOG]: Couldn't preprocess 18 / 1282 molecules.\n[LOG]: New column added: MOL_smiles\n[LOG]: New column added: MOL_molhash_id\n[LOG]: New column added: MOL_molhash_id_no_stereo\n[LOG]: New column added: MOL_num_stereoisomers\n[LOG]: New column added: MOL_num_undefined_stereoisomers\n[LOG]: New column added: MOL_num_defined_stereo_center\n[LOG]: New column added: MOL_num_undefined_stereo_center\n[LOG]: New column added: MOL_num_stereo_center\n[LOG]: New column added: MOL_undefined_E_D\n[LOG]: New column added: MOL_undefined_E/Z\n[LOG]: Default `ecfp` fingerprint is used to visualize the chemical space.\n[LOG]: Molecules with undefined stereocenter detected: 253.\n[IMG]: Dimensions 1200 x 600\n[IMG]: Dimensions 1200 x 2400\n===== outlier_detection =====\n[LOG]: New column added: OUTLIER_SOL\n[LOG]: Found 7 potential outliers with respect to the SOL column for review.\n[IMG]: Dimensions 1200 x 600\n===== discretize =====\n[LOG]: New column added: CLS_SOL\n[IMG]: Dimensions 1200 x 600\n===== Curation Report END =====\n</pre> <p>We can see that there is also images in the report! More advanced broadcasters will display these, such as the <code>HTMLBroadcaster</code>.</p> In\u00a0[7]: Copied! <pre>from auroris.report.broadcaster import HTMLBroadcaster\nimport tempfile\n\ntemp_dir = tempfile.TemporaryDirectory().name\n\nbroadcaster = HTMLBroadcaster(report=report, destination=temp_dir, embed_images=True)\nbroadcaster.broadcast()\n</pre> from auroris.report.broadcaster import HTMLBroadcaster import tempfile  temp_dir = tempfile.TemporaryDirectory().name  broadcaster = HTMLBroadcaster(report=report, destination=temp_dir, embed_images=True) broadcaster.broadcast() Out[7]: <pre>'/var/folders/_7/ffxc1f251dbb5msn977xl4sm0000gr/T/tmps2tt3jrb/index.html'</pre> <p>One can review the above HTML report with embedded visualizations and share it with collaborators.</p> <p>Let's also look at a single row of the new curated dataset!</p> In\u00a0[8]: Copied! <pre>dataset.iloc[0]\n</pre> dataset.iloc[0] Out[8]: <pre>mol                                &lt;rdkit.Chem.rdchem.Mol object at 0x173b7c2e0&gt;\nID                                                                             1\nNAME                                                                   n-pentane\nSOL                                                                        -3.18\nSOL_classification                                                       (A) low\nsmiles                                                                     CCCCC\nsplit                                                                      train\nMOL_smiles                                                                 CCCCC\nMOL_molhash_id                          3cb2e0cf1b50d8f954891abc5dcce90d543cd3d7\nMOL_molhash_id_no_stereo                36551d628217a351e720cdbe676fca3067730a91\nMOL_num_stereoisomers                                                        1.0\nMOL_num_undefined_stereoisomers                                              1.0\nMOL_num_defined_stereo_center                                                0.0\nMOL_num_undefined_stereo_center                                              0.0\nMOL_num_stereo_center                                                        0.0\nMOL_undefined_E_D                                                          False\nMOL_undefined_E/Z                                                              0\nOUTLIER_SOL                                                                False\nCLS_SOL                                                                      0.0\nName: 0, dtype: object</pre> In\u00a0[9]: Copied! <pre>from auroris.curation.functional import detect_outliers\nfrom auroris.visualization import visualize_distribution_with_outliers\n\ny = dataset[\"SOL\"].values\nis_outlier = detect_outliers(y, method=\"zscore\")\nvisualize_distribution_with_outliers(y, is_outlier);\n</pre> from auroris.curation.functional import detect_outliers from auroris.visualization import visualize_distribution_with_outliers  y = dataset[\"SOL\"].values is_outlier = detect_outliers(y, method=\"zscore\") visualize_distribution_with_outliers(y, is_outlier); <p>Depending on the type of bioactivity and its distribution, the above plot helps to highlight data points that are potential outliers (data outside the acceptable range) or strong signals.</p> <p>Reviewing these data points, and removing them if they are truely outliers, can be beneficial for QSAR modeling.</p> <p>The End.</p>"},{"location":"tutorials/getting_started.html#curating-a-toy-dataset","title":"Curating a toy dataset\u00b6","text":"<p>Let's learn about the basic concepts of the <code>auroris</code> library by curating a toy dataset. For the sake of simplicity, we will use the solubility dataset from Datamol. It is worth noting that this dataset is only meant to be used as a toy dataset for pedagogic and testing purposes. It is not a dataset for benchmarking, analysis or model training. Curation can only take us so far. For impactful benchmarks, we rely on high-quality data sources to begin with.</p>"},{"location":"tutorials/getting_started.html#using-the-curator-api","title":"Using the <code>Curator</code> API\u00b6","text":"<p>The recommended way to specify curation workflows is through the <code>Curator</code> API:</p> <ul> <li>A <code>Curator</code> object defines a number of curation steps.</li> <li>Each step should inherit from <code>auroris.curation.actions.BaseAction</code>.</li> <li>The <code>Curator</code> object is serializable. You can thus easily save and load it from JSON, which makes it easy to reproduce a curation workflow.</li> <li>Finally, the <code>Curator</code> produces a <code>CurationReport</code> which summarizes the changes made to a dataset.</li> </ul> <p>Let's define a simple workflow with three steps:</p> <ol> <li>Curate the chemical structures</li> <li>Detect outliers</li> <li>Bin the regression column</li> </ol>"},{"location":"tutorials/getting_started.html#using-the-functional-api","title":"Using the functional API\u00b6","text":"<p><code>auroris</code> provides a functional API to easily and quickly run some curation steps. Let's look at an oulier detection example.</p>"},{"location":"tutorials/stereoisomerism_QSAR.html","title":"Impacts of stereochemistry and activity cliffs in quantitative structure-activity relationships (QSAR) models","text":"In\u00a0[1]: Copied! <pre># Note: Cell is tagged to not show up in the mkdocs build\n%load_ext autoreload\n%autoreload 2\nimport numpy as np\nimport pandas as pd\nfrom copy import copy\nimport nglview as nv\n\nimport datamol as dm\nfrom molfeat.trans.fp import FPVecTransformer\n\nfrom utils import add_3d_coord\n</pre> # Note: Cell is tagged to not show up in the mkdocs build %load_ext autoreload %autoreload 2 import numpy as np import pandas as pd from copy import copy import nglview as nv  import datamol as dm from molfeat.trans.fp import FPVecTransformer  from utils import add_3d_coord <pre></pre> <p>Let's look at molecule Ibuprofen <code>CC(C)CC1=CC=C(C=C1)C(C)C(=O)O</code>, a common and well known compound for treating fever and mild pain.</p> In\u00a0[2]: Copied! <pre>ibu = dm.to_mol(\"CC(C)CC1=CC=C(C=C1)C(C)C(=O)O\")\ndm.to_image(mols=[ibu], highlight_atom=[10])\n</pre> ibu = dm.to_mol(\"CC(C)CC1=CC=C(C=C1)C(C)C(=O)O\") dm.to_image(mols=[ibu], highlight_atom=[10]) Out[2]: <p>The molecule is <code>chiral</code> with one stereocenter at <code>atom 10</code>, meaning that that atom is bound to 4 different groups: a metheyl, a carboxylic acid, a subtituted aromtic ring, and a hydrogen atom (the latter usually not shown in 2D representations).</p> <p><code>Chirality</code> is the property of compounds that posses the same molecular formula and atom connectivity, but exist in different 3D configurations that are a <code>non-superimposable mirror image of each other</code>, similarly to your left and right hand! The different steroisomers of chiral compounds interact differently with beams of polarized light in a phenomenon called <code>optical isomerism</code>.</p> <p>Let's have a look at all the potential stereoisomers for Ibuprofen.</p> In\u00a0[3]: Copied! <pre>ibu_isomers = dm.isomers.enumerate_stereoisomers(ibu)\n\ndm.to_image(\n    ibu_isomers,\n    highlight_atom=[[10], [10]],\n    legends=[\"(S)-Ibuprofen\", \"(R)-Ibuprofen\"],\n    align=True,\n)\n</pre> ibu_isomers = dm.isomers.enumerate_stereoisomers(ibu)  dm.to_image(     ibu_isomers,     highlight_atom=[[10], [10]],     legends=[\"(S)-Ibuprofen\", \"(R)-Ibuprofen\"],     align=True, ) Out[3]: <p>If we 'flat' the aromatic and carboxylic acid groups in the plane of your screen, the methyl group attached to the chiral carbon atom can be pointing <code>up</code> towards you or <code>down</code> away from you (remember that C atoms have a tetrahedral disposition of the four groups bound to it; hydrogen atoms are usually omitted in 2D representations).</p> <p>The molecule posseses a <code>single chiral center</code> that originates <code>two possible stereoisomers</code>. These two stereoisomers are the non-superimposeable mirror image of each other thus they are commonly referred as <code>enantiomers</code>.</p> <p>Let's look at the same enantiomers in 3D:</p> In\u00a0[4]: Copied! <pre># view (S)-Ibuprofen in 3D\nview1 = nv.show_rdkit(ibu_isomers[0])\nview1\n</pre> # view (S)-Ibuprofen in 3D view1 = nv.show_rdkit(ibu_isomers[0]) view1 <pre>NGLWidget()</pre> In\u00a0[5]: Copied! <pre># view (R)-Ibuprofen in 3D\nview2 = nv.show_rdkit(ibu_isomers[1])\nview2\n</pre> # view (R)-Ibuprofen in 3D view2 = nv.show_rdkit(ibu_isomers[1]) view2 <pre>NGLWidget()</pre> <p>Although 2D and 3D representations often make for nice images, in cheminformatics we often represent molecules as <code>SMILES strings</code>.</p> <p>The disposition of the groups on a chiral center in a SMILES string is specified using a single or double <code>@</code> symbol. In our case the chiral carbon atom would be written either <code>C@H</code> or <code>C@@H</code>.</p> <p>In the case of the two enantiomers of Ibuprofen, the SMILES for each enantiomers are:</p> In\u00a0[6]: Copied! <pre>[dm.to_smiles(isomer) for isomer in ibu_isomers]\n</pre> [dm.to_smiles(isomer) for isomer in ibu_isomers] Out[6]: <pre>['CC(C)Cc1ccc([C@H](C)C(=O)O)cc1', 'CC(C)Cc1ccc([C@@H](C)C(=O)O)cc1']</pre> <p>Stereochemistry information can be also embedded in toher type of molecular representation other than SMILES.</p> <p>For example, if we write the two stereiosmers of Ibuprofen in Inchi strings, we see that there is a small difference to identify the chirality of the carbon atom:</p> In\u00a0[7]: Copied! <pre>[dm.to_inchi(isomer) for isomer in ibu_isomers]\n</pre> [dm.to_inchi(isomer) for isomer in ibu_isomers] Out[7]: <pre>['InChI=1S/C13H18O2/c1-9(2)8-11-4-6-12(7-5-11)10(3)13(14)15/h4-7,9-10H,8H2,1-3H3,(H,14,15)/t10-/m0/s1',\n 'InChI=1S/C13H18O2/c1-9(2)8-11-4-6-12(7-5-11)10(3)13(14)15/h4-7,9-10H,8H2,1-3H3,(H,14,15)/t10-/m1/s1']</pre> <p>Molecules are often converted to <code>rdkit.mol</code> objects before being transformed other advanced features vectors. Different stereiosmers are detected as differernt <code>rdkit.mol</code> object (as it should be!):</p> In\u00a0[8]: Copied! <pre>if not dm.same_mol(ibu_isomers[0], ibu_isomers[1]):\n    print(\"The two molecules are not identical!\")\n</pre> if not dm.same_mol(ibu_isomers[0], ibu_isomers[1]):     print(\"The two molecules are not identical!\") <pre>The two molecules are not identical!\n</pre> <p>We have briefly explored stereisomers generated by the presence of a chiral atom, but that is not the only case in which a compound can exist as different stereisomers.</p> <p>Another common case of stereisomerism is the <code>E/Z isomerism</code>. This form of stereisomerism arises from the different arrangment of groups bound via a <code>double bond</code>. The most common cases are compounds containing a <code>C=C</code> double bond, but also <code>C=N</code> and <code>N=N</code> can be commonly found in nature. The <code>E/Z</code> nomenclature derives from German for <code>E</code>ntegen (opposite) and <code>Z</code>usammen (together). In the past another nomenclature for double bond stereochemistry was utilized where E and Z were replaced by 'trans' and 'cis', respectively, but this type of notation is now deprecated and utilized for other scopes.</p> <p>Due to the nature of double bonds, the four substituents (two for each carbon atom) are <code>all placed in the same plane</code> but they can point in different directions such as in the case of 1-bromo-2-chrloropropene:</p> In\u00a0[9]: Copied! <pre>mol = dm.to_mol(\"CC(=CBr)Cl\")\nisomers = dm.isomers.enumerate_stereoisomers(mol)\n\ndm.to_image(\n    isomers,\n    highlight_bond=[[1], [1]],\n    legends=[\"(E)-1-bromo-2-chloroprop-1-ene\", \"(S)-1-bromo-2-chloroprop-1-ene\"],\n    align=True,\n)\n</pre> mol = dm.to_mol(\"CC(=CBr)Cl\") isomers = dm.isomers.enumerate_stereoisomers(mol)  dm.to_image(     isomers,     highlight_bond=[[1], [1]],     legends=[\"(E)-1-bromo-2-chloroprop-1-ene\", \"(S)-1-bromo-2-chloroprop-1-ene\"],     align=True, ) Out[9]: <p>As before, we can see that the two possible stereisomers have the same type of atoms and the same connectivity, but quite evidently <code>the two halogen atoms (bromo and chloro) can either be placed on the same or the opposide 'side' of the C=C double bond</code>'</p> <p>Similarily to chiral centers, SMILES strings have a special symbol to identify E/Z isomers: <code>\\</code> or <code>/</code>:</p> In\u00a0[10]: Copied! <pre>[dm.to_smiles(isomer) for isomer in isomers]\n</pre> [dm.to_smiles(isomer) for isomer in isomers] Out[10]: <pre>['C/C(Cl)=C\\\\Br', 'C/C(Cl)=C/Br']</pre> <p>And as for two enantiomers, E and Z isomers are not the same molecule!</p> In\u00a0[11]: Copied! <pre>if not dm.same_mol(isomers[0], isomers[1]):\n    print(\"The two molecules are not identical!\")\n</pre> if not dm.same_mol(isomers[0], isomers[1]):     print(\"The two molecules are not identical!\") <pre>The two molecules are not identical!\n</pre> In\u00a0[12]: Copied! <pre>assert dm.to_inchi(ibu_isomers[0]) != dm.to_inchi(ibu_isomers[1])\n</pre> assert dm.to_inchi(ibu_isomers[0]) != dm.to_inchi(ibu_isomers[1]) <p>We have seen moelcules that contain a single chiral center or a double bond and how we define their correspoding stereisomers. Nature is very often a bit more creative, and it is very common to ecnoutenr compounds that contains <code>multiple chiral atoms and/or one or more double bonds</code>!</p> <p>Please, refer to the diagram at the beginning of this tutorial for a complete overview of all the possibilities but here a couple of examples of compounds containing multiple types of stereochemical information:</p> In\u00a0[13]: Copied! <pre># Multiple stereocenters (chiral atoms) in one molecule\nmols_1 = dm.to_mol(\"CC(C(=O)O)C(N)C\")\ndm.to_image(dm.isomers.enumerate_stereoisomers(mols_1), align=True)\n</pre> # Multiple stereocenters (chiral atoms) in one molecule mols_1 = dm.to_mol(\"CC(C(=O)O)C(N)C\") dm.to_image(dm.isomers.enumerate_stereoisomers(mols_1), align=True) Out[13]: In\u00a0[14]: Copied! <pre># Optical isomerism and E/Z isomerism in one molecule\nmols_2 = dm.to_mol(\"O=C1OC(=CI)CCC1c1cccc2ccccc12\")\ndm.to_image(dm.isomers.enumerate_stereoisomers(mols_2), align=True)\n</pre> # Optical isomerism and E/Z isomerism in one molecule mols_2 = dm.to_mol(\"O=C1OC(=CI)CCC1c1cccc2ccccc12\") dm.to_image(dm.isomers.enumerate_stereoisomers(mols_2), align=True) Out[14]: <p>Here we use featurizers(molecular transformers) from molfeat which is a hub of molecular featurizers. It supports a wide variety of out-of-the-box molecular featurizers from Fingerprints, pretrained-featurizers, deep embeddings (proteins+small mol), to molecular descriptors.</p> In\u00a0[15]: Copied! <pre># generate conformers/3d coordinates\nmol1_3d = dm.conformers.generate(ibu_isomers[0])\nmol2_3d = dm.conformers.generate(ibu_isomers[1])\nmol3_3d = dm.conformers.generate(isomers[0])\nmol4_3d = dm.conformers.generate(isomers[1])\n</pre> # generate conformers/3d coordinates mol1_3d = dm.conformers.generate(ibu_isomers[0]) mol2_3d = dm.conformers.generate(ibu_isomers[1]) mol3_3d = dm.conformers.generate(isomers[0]) mol4_3d = dm.conformers.generate(isomers[1]) <p>Featurizer 1: Let\u2019s use the ECFP featurizer, which encodes the presence of specific substructures or features in a molecule. It is one of the most commonly used molecular representations in QSAR modeling.</p> In\u00a0[16]: Copied! <pre>transfomer_1 = FPVecTransformer(kind=\"ecfp:4\", length=2042)\nfp1 = transfomer_1(mol1_3d)\nfp2 = transfomer_1(mol2_3d)\nif np.array_equal(fp1, fp2):\n    print(f\"This featurizer '{transfomer_1.kind}' can't differenciate the two enantiomers!\")\n</pre> transfomer_1 = FPVecTransformer(kind=\"ecfp:4\", length=2042) fp1 = transfomer_1(mol1_3d) fp2 = transfomer_1(mol2_3d) if np.array_equal(fp1, fp2):     print(f\"This featurizer '{transfomer_1.kind}' can't differenciate the two enantiomers!\") <pre>This featurizer 'ecfp:4' can't differenciate the two enantiomers!\n</pre> In\u00a0[17]: Copied! <pre>fp3 = transfomer_1(mol3_3d)\nfp4 = transfomer_1(mol4_3d)\nif np.array_equal(fp3, fp4):\n    print(f\"This featurizer '{transfomer_1.kind}' can't differenciate the two diastereoisomers!\")\n</pre> fp3 = transfomer_1(mol3_3d) fp4 = transfomer_1(mol4_3d) if np.array_equal(fp3, fp4):     print(f\"This featurizer '{transfomer_1.kind}' can't differenciate the two diastereoisomers!\") <pre>This featurizer 'ecfp:4' can't differenciate the two diastereoisomers!\n</pre> <p>Now let\u2019s explore more sophisticated featurizers that captures the 3D information of molecules.</p> <p>Featurizer 2: 3D version of the CATS pharmacophores computed with the Pharm2D module in RDKit.</p> In\u00a0[18]: Copied! <pre>from molfeat.trans.base import MoleculeTransformer\nfrom molfeat.calc.pharmacophore import Pharmacophore3D\n\n# define transformer\ntransformer_2 = MoleculeTransformer(featurizer=Pharmacophore3D(factory=\"cats\"), dtype=float)\nfeat1 = transformer_2(mol1_3d)\nfeat2 = transformer_2(mol2_3d)\nif not np.array_equal(feat1, feat2):\n    print(f\"This featurizer '{transformer_2.featurizer.factory}' can differenciate the enantiomers!\")\n</pre> from molfeat.trans.base import MoleculeTransformer from molfeat.calc.pharmacophore import Pharmacophore3D  # define transformer transformer_2 = MoleculeTransformer(featurizer=Pharmacophore3D(factory=\"cats\"), dtype=float) feat1 = transformer_2(mol1_3d) feat2 = transformer_2(mol2_3d) if not np.array_equal(feat1, feat2):     print(f\"This featurizer '{transformer_2.featurizer.factory}' can differenciate the enantiomers!\") <pre>This featurizer 'cats' can differenciate the enantiomers!\n</pre> In\u00a0[19]: Copied! <pre>feat3 = transformer_2(mol3_3d)\nfeat4 = transformer_2(mol4_3d)\nif not np.array_equal(feat1, feat2):\n    print(f\"This featurizer '{transformer_2.featurizer.factory}' can differenciate the diastereoisomers!\")\n</pre> feat3 = transformer_2(mol3_3d) feat4 = transformer_2(mol4_3d) if not np.array_equal(feat1, feat2):     print(f\"This featurizer '{transformer_2.featurizer.factory}' can differenciate the diastereoisomers!\") <pre>This featurizer 'cats' can differenciate the diastereoisomers!\n</pre> <p>Please find more deatails about featurizer pharm3D-cats and explore other available featurizers on molfeat page.</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[20]: Copied! <pre># Load data set of small molecule inhibitors of dopamine receptor D2\ndata = pd.read_csv(\"data/dopamine_d2_data.csv\")\n</pre> # Load data set of small molecule inhibitors of dopamine receptor D2 data = pd.read_csv(\"data/dopamine_d2_data.csv\") In\u00a0[3]: Copied! <pre>mol_col = \"MOL_smiles\"  # molecule smiles strings\nval_col = \"CLS_pChEMBL Value\"  # class label for binding affinity\n\nmols = dm.utils.parallelized(\n    fn=lambda mol: add_3d_coord(mol),\n    inputs_list=data[mol_col],\n    progress=True,\n    n_jobs=10,\n)\ndata[\"mol\"] = mols\n</pre> mol_col = \"MOL_smiles\"  # molecule smiles strings val_col = \"CLS_pChEMBL Value\"  # class label for binding affinity  mols = dm.utils.parallelized(     fn=lambda mol: add_3d_coord(mol),     inputs_list=data[mol_col],     progress=True,     n_jobs=10, ) data[\"mol\"] = mols In\u00a0[22]: Copied! <pre>## `dm.conformers.generate` is a better choice for 3d coordinates and conformer generation.\n## Note: this function might take longer time\n# mols = dm.utils.parallelized(\n#     fn=lambda mol: dm.conformers.generate(dm.to_mol(mol)),\n#     inputs_list=data[mol_col],\n#     progress=True,\n#     n_jobs=10,\n# )\n# data[\"mol\"] = mols\n</pre> ## `dm.conformers.generate` is a better choice for 3d coordinates and conformer generation. ## Note: this function might take longer time # mols = dm.utils.parallelized( #     fn=lambda mol: dm.conformers.generate(dm.to_mol(mol)), #     inputs_list=data[mol_col], #     progress=True, #     n_jobs=10, # ) # data[\"mol\"] = mols In\u00a0[23]: Copied! <pre># the dataset was pre-split to train/test based on the presence of activity cliffs\ndata_train = data.query(\"split == 'train'\")\ndata_test = data.query(\"split == 'test'\")\n</pre> # the dataset was pre-split to train/test based on the presence of activity cliffs data_train = data.query(\"split == 'train'\") data_test = data.query(\"split == 'test'\") In\u00a0[24]: Copied! <pre>col_AC = \"AC_CLS_pChEMBL Value\"  # boolean: whether the molecule show activity cliff in the dataset\ndata.groupby(\"split\")[col_AC].value_counts()\n</pre> col_AC = \"AC_CLS_pChEMBL Value\"  # boolean: whether the molecule show activity cliff in the dataset data.groupby(\"split\")[col_AC].value_counts() Out[24]: <pre>split  AC_CLS_pChEMBL Value\ntest   False                   1361\n       True                     103\ntrain  False                   5451\n       True                     102\nName: count, dtype: int64</pre> In\u00a0[25]: Copied! <pre># Define the model with specified parameters\n\nfrom sklearn.ensemble import RandomForestClassifier\n\nmodel = RandomForestClassifier(\n    n_estimators=100,\n    max_depth=None,\n    min_samples_split=2,\n    min_samples_leaf=1,\n    max_features=\"sqrt\",\n    bootstrap=True,\n    criterion=\"gini\",\n    verbose=True,\n    n_jobs=-1,\n)\n</pre> # Define the model with specified parameters  from sklearn.ensemble import RandomForestClassifier  model = RandomForestClassifier(     n_estimators=100,     max_depth=None,     min_samples_split=2,     min_samples_leaf=1,     max_features=\"sqrt\",     bootstrap=True,     criterion=\"gini\",     verbose=True,     n_jobs=-1, ) <p>Model 1: <code>RandomForestClassifier</code> + <code>ECFP:4</code></p> In\u00a0[26]: Copied! <pre># Transform with featurizer which can't differe stereoisomers\ntransformer_1 = FPVecTransformer(kind=\"ecfp:4\", dtype=float)\nX_train = transformer_1(data_train[\"mol\"].values)\n\n# Define the labels\ny_train = data_train[val_col].values\n\nmodel_1 = copy(model)\n# Fit the model\nmodel_1.fit(X_train, y_train)\n</pre> # Transform with featurizer which can't differe stereoisomers transformer_1 = FPVecTransformer(kind=\"ecfp:4\", dtype=float) X_train = transformer_1(data_train[\"mol\"].values)  # Define the labels y_train = data_train[val_col].values  model_1 = copy(model) # Fit the model model_1.fit(X_train, y_train) <pre>[Parallel(n_jobs=-1)]: Using backend ThreadingBackend with 10 concurrent workers.\n[Parallel(n_jobs=-1)]: Done  30 tasks      | elapsed:    0.1s\n[Parallel(n_jobs=-1)]: Done 100 out of 100 | elapsed:    0.3s finished\n</pre> Out[26]: <pre>RandomForestClassifier(n_jobs=-1, verbose=True)</pre>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.\u00a0\u00a0RandomForestClassifier?Documentation for RandomForestClassifieriFitted<pre>RandomForestClassifier(n_jobs=-1, verbose=True)</pre> <p>Model 2: <code>RandomForestClassifier</code> + <code>pharm3D-cats</code></p> In\u00a0[27]: Copied! <pre>X_train = transformer_2(data_train[\"mol\"].values)\n\n# Define the labels\ny_train = data_train[val_col].values\nmodel_2 = copy(model)\n# Fit the model\nmodel_2.fit(X_train, y_train)\n</pre> X_train = transformer_2(data_train[\"mol\"].values)  # Define the labels y_train = data_train[val_col].values model_2 = copy(model) # Fit the model model_2.fit(X_train, y_train) <pre>[Parallel(n_jobs=-1)]: Using backend ThreadingBackend with 10 concurrent workers.\n[Parallel(n_jobs=-1)]: Done  30 tasks      | elapsed:    0.1s\n[Parallel(n_jobs=-1)]: Done 100 out of 100 | elapsed:    0.3s finished\n</pre> Out[27]: <pre>RandomForestClassifier(n_jobs=-1, verbose=True)</pre>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.\u00a0\u00a0RandomForestClassifier?Documentation for RandomForestClassifieriFitted<pre>RandomForestClassifier(n_jobs=-1, verbose=True)</pre> In\u00a0[28]: Copied! <pre>results = {\"overall\": {}, \"AC\": {}}\n</pre> results = {\"overall\": {}, \"AC\": {}} In\u00a0[29]: Copied! <pre>from utils import evaluate\n\nresults[\"overall\"][\"rf+ecfp\"] = evaluate(data_test, transformer_1, model_1, mol_col=\"mol\", val_col=val_col)\n\nresults[\"overall\"][\"rf+pharm3Dcats\"] = evaluate(\n    data_test, transformer_2, model_2, mol_col=\"mol\", val_col=val_col\n)\n</pre> from utils import evaluate  results[\"overall\"][\"rf+ecfp\"] = evaluate(data_test, transformer_1, model_1, mol_col=\"mol\", val_col=val_col)  results[\"overall\"][\"rf+pharm3Dcats\"] = evaluate(     data_test, transformer_2, model_2, mol_col=\"mol\", val_col=val_col ) <pre>[Parallel(n_jobs=10)]: Using backend ThreadingBackend with 10 concurrent workers.\n[Parallel(n_jobs=10)]: Done  30 tasks      | elapsed:    0.0s\n[Parallel(n_jobs=10)]: Done 100 out of 100 | elapsed:    0.0s finished\n[Parallel(n_jobs=10)]: Using backend ThreadingBackend with 10 concurrent workers.\n[Parallel(n_jobs=10)]: Done  30 tasks      | elapsed:    0.0s\n[Parallel(n_jobs=10)]: Done 100 out of 100 | elapsed:    0.0s finished\n</pre> In\u00a0[30]: Copied! <pre>pd.DataFrame(results[\"overall\"])\n</pre> pd.DataFrame(results[\"overall\"]) Out[30]: rf+ecfp rf+pharm3Dcats precision 0.807947 0.749466 recall 0.798116 0.705505 f1-score 0.802038 0.711946 support 1464.000000 1464.000000 In\u00a0[31]: Copied! <pre>results[\"AC\"][\"rf+ecfp\"] = evaluate(\n    data_test.query(\"`AC_CLS_pChEMBL Value` == True\"),\n    transformer_1,\n    model_1,\n    mol_col=\"mol\",\n    val_col=val_col,\n)\nresults[\"AC\"][\"rf+pharm3Dcats\"] = evaluate(\n    data_test.query(\"`AC_CLS_pChEMBL Value` == True\"),\n    transformer_2,\n    model_2,\n    mol_col=\"mol\",\n    val_col=val_col,\n)\n</pre> results[\"AC\"][\"rf+ecfp\"] = evaluate(     data_test.query(\"`AC_CLS_pChEMBL Value` == True\"),     transformer_1,     model_1,     mol_col=\"mol\",     val_col=val_col, ) results[\"AC\"][\"rf+pharm3Dcats\"] = evaluate(     data_test.query(\"`AC_CLS_pChEMBL Value` == True\"),     transformer_2,     model_2,     mol_col=\"mol\",     val_col=val_col, ) <pre>[Parallel(n_jobs=10)]: Using backend ThreadingBackend with 10 concurrent workers.\n[Parallel(n_jobs=10)]: Done  30 tasks      | elapsed:    0.0s\n[Parallel(n_jobs=10)]: Done 100 out of 100 | elapsed:    0.0s finished\n[Parallel(n_jobs=10)]: Using backend ThreadingBackend with 10 concurrent workers.\n[Parallel(n_jobs=10)]: Done  30 tasks      | elapsed:    0.0s\n[Parallel(n_jobs=10)]: Done 100 out of 100 | elapsed:    0.0s finished\n</pre> In\u00a0[32]: Copied! <pre>pd.DataFrame(results[\"AC\"])\n</pre> pd.DataFrame(results[\"AC\"]) Out[32]: rf+ecfp rf+pharm3Dcats precision 0.290427 0.480769 recall 0.292642 0.481887 f1-score 0.290192 0.475751 support 103.000000 103.000000 <p>QSAR modeling involving stereisomers and activity cliffs is always challenging. The results above demonstrate that, while the model trained with <code>pharm3D-cats</code> underperformed in overall prediction accuracy, it significantly outperformed when predicting the activity of stereoisomers with activity cliffs. This highlights the importance of using proper molecular representations that effectively capture stereochemical information.</p> <p>When applying predictive models to a different set of molecules, it is crucial to carefully select the appropriate model for deployment. In this example, if we aim to make predictions on a lead series of molecules that contains stereochemical features that are essential for binding to the D2 target, the model <code>rf+pharm3Dcats</code> should be chosen. Conversely, for datasets consisting of non-chiral molecules or compounds that do not contain any stereogenic feature, the <code>rf+ecfp</code> model would be sufficient.</p> <p>Careful data curation and autiding is essential to determine whether the observed bioactivity of a series of compounds is highly dependent on their stereochemistry or not. <code>Auroris</code> simplifies and streamlines this process by providing the StereoIsomerACDetection module and the corresponding  detect_streoisomer_activity_cliff function to easily assess this instances.</p> <p>For guidance on how to combine different Auroris modules for small molecule dataset curation, please checkout this tutorial.</p> <p>The end.</p>"},{"location":"tutorials/stereoisomerism_QSAR.html#stereoisomerization","title":"Stereoisomerization\u00b6","text":""},{"location":"tutorials/stereoisomerism_QSAR.html#optical-isomerism","title":"Optical isomerism\u00b6","text":""},{"location":"tutorials/stereoisomerism_QSAR.html#ez-stereisomerism","title":"E/Z Stereisomerism\u00b6","text":""},{"location":"tutorials/stereoisomerism_QSAR.html#is-stereochemistry-always-important-in-qsar","title":"Is stereochemistry always important in QSAR?\u00b6","text":"<p>Short answer: <code>YES!</code> The 3D arragnemtn of groups in a molecule has a profound impact on how different stereisomers interact with biological targets. Remember that every single protein is nothing more that a very big molecule that contains a large amount of chiral centers, therefore <code>proteins and biological entities are stereisomers themselves</code>. Different stereisomers (e.g., enantiomers, diastereisomers) will interact differently with their biological targets showing vastly different pharmacology, binding affinity, activty and potency, etc...</p> <p>Examples: The binding site of the \u03b22-adrenergic receptor has a specific 3D shape where (R)-albuterol fits into more precisely than the (S)-albuterol. (R)-albuterol provides more effective treatment with fewer side effects targeting \u03b22-adrenergic receptors in comparison to (S)-albuterol. Another example is Penicillamine, where the (S) enantiomer shows the desired antiarthritic activity, whereas the (R) enantiomer is extremely toxic!</p> <p>In the <code>rare cases</code> where stereochemistry is found not to affect the biological activity of a series of compounds, the stereochemical information may be uncessessary in handling these datasets (always check before removing or ignoring stereochemistry).</p> <p>Furthermore, stereochemistry may have also an impact on the <code>physical</code> (e.g., solubility, melting point) and <code>pysicochemical</code> (e.g., logP, TPSA)  properties of a molecule, but not always: - <code>Enantiomers</code> always show the same physical and physicochemical properties; - <code>Diastereisomers</code> often show different physical properties but they have the same physicochemical properties.</p> <p>In conclusion, it is always a good (and safe!) choice to include stereochemical information when possible, but in certain cases and for certain type of analyses it may not be necessary.</p> <p>Stereochemistry in cheminformatics</p> <p>As mentioned above, when studying the interaction between small molecules and proteins, it is very important to define <code>ALL</code> the stereochemical information of a molecule, if possible. Missing/unknown information or limitations in the chemical synthesis and purification of chemcial compounds may result in the impossibility to fully define the stereochemistry of these molecules.</p> <p>Undefined or partially defined stereochmical information is unfortunately quite common, especially in the early stages of a drug developement program, and it usually challenges efforts in QSAR modeling.</p> <p>It is worth mentioning that, in early-stage drug dicsovery programs, where high-throughput screening (HTS) is utilized to identify hit compouds from very large libraries, the focus is more oritented towards broad activity trends rather than precise stereochemical interactions. As a result, at this stage, stereochemistry may be ignored by rotuinely testing racemic mixtures (mixtures containg equal amounts of the possible enantiomers), and mistures of diastereisomers. Therefore, when utilizing models trained on such data lacking accurate stereochemical inforamtion, it is important to specify the limitations of these models, particularly regarding their applicability to other molecular databases.</p>"},{"location":"tutorials/stereoisomerism_QSAR.html#stereisomers-with-activity-cliff-and-the-impact-on-qsar","title":"Stereisomers with activity cliff and the impact on QSAR\u00b6","text":"<p>Stereoisomers might exhibit activity cliffs: different stereisomers of the same molecule showing large differences in biological activity. Stereisomers associated to activity cliffs can pose challenges to QSAR modeling by creating sharp contrasts in biological activity vs chemical connectivity that are not easily captured by standard models.</p> <p>Precise representation of stereochemistry and careful model design are crucial for addressing these challenges and improving the predictive accuracy and interpretability of QSAR models.</p>"},{"location":"tutorials/stereoisomerism_QSAR.html#choice-of-molecular-representations-for-stereoisomerism","title":"Choice of molecular representations for stereoisomerism\u00b6","text":""},{"location":"tutorials/stereoisomerism_QSAR.html#qsar-modeling-with-stereoisomers-exhibiting-activity-cliffs","title":"QSAR modeling with stereoisomers exhibiting activity cliffs\u00b6","text":"<p>In this section, we\u2019ll take a closer look at how activity cliffs between stereoisomers can impact the predictive performance of QSAR modeling.</p>"},{"location":"tutorials/stereoisomerism_QSAR.html#example-case-dopamine-receptor-d2","title":"Example case: Dopamine receptor D2\u00b6","text":"<p>The dopamine D2 receptor, like many G-protein-coupled receptors (GPCRs), exhibits stereoselectivity, meaning that stereisomers A of a small molecule may bind more effectively than stereisomer B, C,... of the same molecule. In these common cases, stereoselectivyt plays a crucial role in the pharmacological effects of drugs targeting the D2 receptor Xiao et al. 2014.</p> <p>Here, our goal is to train predictive models that perform well on both molecules that exhibit activity cliffs and those that do not.</p> <p><code>Note</code>: The dataset used in this notebooks is heterogeneous extracted from CHEMBL for demonstration purpose.</p>"},{"location":"tutorials/stereoisomerism_QSAR.html#training-with-simple-randomforest-model","title":"Training with simple RandomForest model\u00b6","text":"<p>To evaluate the impact of including stereochemistry information on prediction performance, we will train two QSAR models using the same machine learning algorithm and parameters.</p> <p>One model will use the <code>ECFP:4</code> featurizer, which does not capture stereochemistry, while the other will use the <code>pharm3D-cats</code> featurizer, which includes 3D stereochemical information.</p>"},{"location":"tutorials/stereoisomerism_QSAR.html#compare-the-predictive-performance-on-test-set","title":"Compare the predictive performance on test set\u00b6","text":""},{"location":"tutorials/stereoisomerism_QSAR.html#overall-performance-on-entire-test-set","title":"Overall performance on entire test set\u00b6","text":""},{"location":"tutorials/stereoisomerism_QSAR.html#performance-on-stereoisomers-which-show-activity-cliff","title":"Performance on stereoisomers which show activity cliff\u00b6","text":""},{"location":"tutorials/stereoisomerism_QSAR.html#final-notes","title":"Final notes\u00b6","text":""},{"location":"tutorials/utils.html","title":"Utils","text":"In\u00a0[\u00a0]: Copied! <pre>from typing import Callable\n</pre> from typing import Callable In\u00a0[\u00a0]: Copied! <pre>from rdkit import Chem\nfrom rdkit.Chem import AllChem\n</pre> from rdkit import Chem from rdkit.Chem import AllChem In\u00a0[\u00a0]: Copied! <pre>import datamol as dm\nimport pandas as pd\n</pre> import datamol as dm import pandas as pd In\u00a0[\u00a0]: Copied! <pre>from sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import classification_report\n</pre> from sklearn.ensemble import RandomForestClassifier from sklearn.metrics import classification_report In\u00a0[\u00a0]: Copied! <pre>def add_3d_coord(mol: dm.Mol):\n    \"\"\"Add 3d coordinates to molecule\"\"\"\n    try:\n        # convert to mol object\n        mol = dm.to_mol(mol)\n\n        # Add hydrogens\n        mol = Chem.AddHs(mol)\n\n        # Generate 3D coordinates\n        AllChem.EmbedMolecule(mol, randomSeed=42)\n\n        # Optimize the 3D structure\n        AllChem.UFFOptimizeMolecule(mol)\n        return mol\n    except Exception as e:\n        print(e)\n        return None\n</pre> def add_3d_coord(mol: dm.Mol):     \"\"\"Add 3d coordinates to molecule\"\"\"     try:         # convert to mol object         mol = dm.to_mol(mol)          # Add hydrogens         mol = Chem.AddHs(mol)          # Generate 3D coordinates         AllChem.EmbedMolecule(mol, randomSeed=42)          # Optimize the 3D structure         AllChem.UFFOptimizeMolecule(mol)         return mol     except Exception as e:         print(e)         return None In\u00a0[\u00a0]: Copied! <pre>def evaluate(\n    data_test: pd.DataFrame,\n    transformer: Callable,\n    model: RandomForestClassifier,\n    mol_col: str,\n    val_col: str,\n):\n    \"\"\"Evaluate on test set with classification metrics\"\"\"\n    X_test = transformer(data_test[mol_col].values)\n    y_test = data_test[val_col].values\n\n    y_pred = model.predict(X_test)\n    report = classification_report(y_test, y_pred, output_dict=True)\n    return report[\"macro avg\"]\n</pre> def evaluate(     data_test: pd.DataFrame,     transformer: Callable,     model: RandomForestClassifier,     mol_col: str,     val_col: str, ):     \"\"\"Evaluate on test set with classification metrics\"\"\"     X_test = transformer(data_test[mol_col].values)     y_test = data_test[val_col].values      y_pred = model.predict(X_test)     report = classification_report(y_test, y_pred, output_dict=True)     return report[\"macro avg\"]"}]}